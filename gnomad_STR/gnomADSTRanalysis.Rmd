---
title: "gnomADSTRanalysis"
author: "Laurel Hiatt"
date: "2023-04-13"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library('dplyr')
library('stringr')
library('ggplot2')
library('cowplot')
library("tidyverse")
library("broom")
library(DescTools)
theme_set(theme_cowplot())
options(stringsAsFactors = FALSE)
```

## This is where I will put cool explanations of things

### Summary of STR table

### Summary of gnomADSTRcalls


### To do
- use allele2lowerbound instead of allele2... woo!
- if recessive, are both alleles >?
- other stuff ####
- NMDS 
- CI everywhere
#### Look at AD, AR

https://gnomad.broadinstitute.org/news/2022-01-the-addition-of-short-tandem-repeat-calls-to-gnomad/
```{r import}
gnomADSTRcalls = read.csv('/Users/quinlan/Documents/Quinlan-PhD/UDN+STRdb/STRpapercode/gnomad_STR/gnomAD_STR_genotypes__2022_01_20.tsv.gz', sep = '\t', stringsAsFactors = FALSE)

STR_table <- read.csv('/Users/quinlan/Documents/Quinlan-PhD/UDN+STRdb/STRpapercode/gnomad_STR/STR_table_04072023.csv', stringsAsFactors = FALSE)

#str(STR_table)

#str(gnomADSTRcalls)

STR_table$pathogenic_max[STR_table$pathogenic_max == "11,000"] <- 11000
STR_table$pathogenic_max <- as.integer(STR_table$pathogenic_max)
```


## This clean up helps the STR resource table match the gnomad data
``` {r cleanup}
#cleaning up table to match gnomad syntax
STR_table$gene[STR_table$gene == "AFF2/FMR2"] <- "AFF2"
STR_table$gene[STR_table$gene == "MARCH6"] <- "MARCHF6"
STR_table$gene[STR_table$gene == "C9orf72"] <- "C9ORF72"
STR_table$gene[STR_table$gene == "ATXN8OS/ATXN8"] <- "ATXN8OS"
STR_table$gene[STR_table$gene == "NUTM2B-AS1/NUTM2B-AS1"] <- "NUTM2B-AS1"
STR_table$gene[STR_table$gene == "ARX" & STR_table$stop_hg38 == 25013697] <- "ARX_1"
STR_table$gene[STR_table$gene == "ARX" & STR_table$stop_hg38 == 25013565] <- "ARX_2"
STR_table$gene[STR_table$gene == "HOXA13" & STR_table$stop_hg38 == 27199966] <- "HOXA13_1"
STR_table$gene[STR_table$gene == "HOXA13" & STR_table$stop_hg38 == 27199861] <- "HOXA13_2"
STR_table$gene[STR_table$gene == "HOXA13" & STR_table$stop_hg38 == 27199732] <- "HOXA13_3"

```

## This is just to check and see what doesn't match
``` {r checkdata}
unique(gnomADSTRcalls$Id) -> genelist
unique(STR_table$gene) -> tablegenelist
sort(tablegenelist) -> tablegenelist


# what are the differences between the table and the gnomad gene list
tablegenelist[!(tablegenelist %in% genelist)]

genelist[!(genelist %in% tablegenelist)]

# what are the same genesbetween the table and the gnomad gene list
tablegenelist[(tablegenelist %in% genelist)]
length(tablegenelist[(tablegenelist %in% genelist)])
# CCG in HTT is non-pathogenic but also sometimes surveyed; there might be some association with disease as founder effect?
```

## Let's merge some data
### We are also going to make some new age columns
### And then we're separating out the genotype confidence intervals
```{r merge}
STR_table_clean <-subset(STR_table, select=c("disease_id", "gene",
                                             "repeatunit_ref", "Inheritance",
                                             "type", "normal_min", "normal_max",
                                             "intermediate_min", "intermediate_max",
                                             "pathogenic_min", "pathogenic_max",
                                             "repeat_unit_lenth", "age_onset_min",
                                             "age_onset_max", "novel", "repeatunit_path_norm"))

STR_table_clean <- STR_table_clean %>%
  rename("Id" = "gene")


gnomADSTRcalls$Age[gnomADSTRcalls$Age == '<20'] <- "00-19"
gnomADSTRcalls$Age[gnomADSTRcalls$Age == '>80'] <- "81-99"

gnomADSTRcalls$AgeMax = as.numeric(str_sub(gnomADSTRcalls$Age,-2,-1)) # get last two char in Age. Assumes all <100

gnomADSTRcalls$AgeMin = as.numeric(str_sub(gnomADSTRcalls$Age,1,2)) # get last two char in Age. Assumes all <100


gnomADSTRcalls[c("Allele1LowerBound", "Allele1HigherBound", "Allele2LowerBound", "Allele2HigherBound")] <- as.data.frame(do.call(rbind, strsplit(gsub("/", "-", gnomADSTRcalls$GenotypeConfidenceInterval), "-")), stringsAsFactors = FALSE)
gnomADSTRcalls[c("Allele1LowerBound", "Allele1HigherBound", "Allele2LowerBound", "Allele2HigherBound")] <- lapply(gnomADSTRcalls[c("Allele1LowerBound", "Allele1HigherBound", "Allele2LowerBound", "Allele2HigherBound")], as.integer)

gnomADSTRcalls[c("Allele1LowerBoundOTR", "Allele1HigherBoundOTR", "Allele2LowerBoundOTR", "Allele2HigherBoundOTR")] <- as.data.frame(do.call(rbind, strsplit(gsub("/", "-", gnomADSTRcalls$GenotypeConfidenceIntervalUsingOfftargetRegions), "-")), stringsAsFactors = FALSE)
gnomADSTRcalls[c("Allele1LowerBoundOTR", "Allele1HigherBoundOTR", "Allele2LowerBoundOTR", "Allele2HigherBoundOTR")] <- lapply(gnomADSTRcalls[c("Allele1LowerBound", "Allele1HigherBoundOTR", "Allele2LowerBoundOTR", "Allele2HigherBoundOTR")], as.integer)


#table(gnomADSTRcalls$Age)

#table(gnomADSTRcalls$AgeMin)
#table(gnomADSTRcalls$AgeMax)

total <- merge(STR_table_clean,gnomADSTRcalls,by="Id")

```

## Let's get a subset of the merged data (optional)
``` {r subset}
#total <- sample_n(total, 10000)
```

## Let's Ensure Allele2 > Allele1
- Check max of allele1 and allele2 (na.rm = TRUE)


``` {r allelecheck}
#table(gnomADSTRcalls$Allele2 >= gnomADSTRcalls$Allele1, useNA = "ifany")
#pmax(gnomADSTRcalls$Allele1, gnomADSTRcalls$Allele2, na.rm = TRUE)

# gnomADSTRcalls_noallele2 <- gnomADSTRcalls[is.na(gnomADSTRcalls$Allele2),]
# table(gnomADSTRcalls_noallele2$Allele1)

gnomADSTRcalls$AlleleLargest <- pmax(gnomADSTRcalls$Allele1, gnomADSTRcalls$Allele2, na.rm = TRUE)
table(gnomADSTRcalls$AlleleLargest)
table(gnomADSTRcalls$AlleleLargest >= gnomADSTRcalls$Allele1, useNA = "ifany")

```

## Loop from harriet for allele distribution with age vs no age available
```{r loop}
for (locus in unique(gnomADSTRcalls$Id)) {
  ggplot(subset(gnomADSTRcalls, Id == locus)) + 
    geom_histogram(aes(x = Allele2, fill = Age), alpha = 0.5) + 
    facet_wrap(~AgeMax == 'age_not_available', scales = 'free_y') +
    ggtitle(locus)
  ggsave(paste0(locus,'_allele2_age_available.png'))
}

for (locus in unique(gnomADSTRcalls$Id)) {
  ggplot(subset(gnomADSTRcalls, Id == locus)) + 
    geom_histogram(aes(x = Allele2UsingOfftargetRegions, fill = Age), alpha = 0.5) + 
    facet_wrap(~AgeMax == '_OTR_age_not_available', scales = 'free_y') +
    ggtitle(locus)
  ggsave(paste0(locus,'_OTR_allele2_age_available.png'))
}

table(gnomADSTRcalls$Age)

wilcox.test(subset(gnomADSTRcalls, Age == 'age_not_available')$Allele2, 
                          subset(gnomADSTRcalls, Age != 'age_not_available')$Allele2)


# results <- data.frame()  # create an empty dataframe to store results
# 
# for (locus in unique(gnomADSTRcalls$Id)) {
#   p <- tidy(ks.test(subset(gnomADSTRcalls, Age == 'age_not_available' & Id == locus)$Allele2, 
#                          subset(gnomADSTRcalls, Age != 'age_not_available'& Id == locus)$Allele2))
#   results <- rbind(results, data.frame(Id = locus, statistic = p$statistic, p.value = p$p.value))
# }
# 
# print(results)

# NOT ENOUGH Y DATA!!!
```

## PCR comparison
``` {r PCR, fig.width=15,fig.height=10}

ggplot(gnomADSTRcalls) + 
  geom_histogram(aes(x = Allele2, fill = PcrProtocol), alpha = 0.5) + 
  facet_wrap(~PcrProtocol, scales = 'free_y') +
  ggtitle('PCR Protocol')

# 
# wilcox.test(subset(gnomADSTRcalls, PcrProtocol == 'pcr_free')$Allele2, 
#              subset(gnomADSTRcalls, PcrProtocol == 'pcr_plus')$Allele2)
# p <- tidy(wilcox.test(subset(gnomADSTRcalls, PcrProtocol == 'pcr_free')$Allele2, 
#              subset(gnomADSTRcalls, PcrProtocol == 'pcr_plus')$Allele2))


# for (locus in unique(gnomADSTRcalls$Id)) {
#   cat(paste0(locus))
#   p <- tidy(wilcox.test(subset(gnomADSTRcalls, PcrProtocol == 'pcr_free' & Id == locus)$Allele2, 
#              subset(gnomADSTRcalls, PcrProtocol == 'pcr_plus'& Id == locus)$Allele2))
#   cat('\n') 
#   cat("The statistic is \n")
#   cat(p$statistic)
#   cat('\n') 
#   cat("The p-value is \n")
#   cat(p$p.value)
#   cat('\n') 
# }

results <- data.frame()  # create an empty dataframe to store results

for (locus in unique(gnomADSTRcalls$Id)) {
  p <- tidy(wilcox.test(subset(gnomADSTRcalls, PcrProtocol == 'pcr_free' & Id == locus)$Allele2, 
                         subset(gnomADSTRcalls, PcrProtocol == 'pcr_plus'& Id == locus)$Allele2))
  results <- rbind(results, data.frame(Id = locus, statistic = p$statistic, p.value = p$p.value))
}

print(results)

ggplot(results, aes(x = Id, y = p.value, color = Id)) +
  geom_point() +
  geom_hline(yintercept = 0.05, linetype = "dashed") +
  labs(x = "Locus", y = "p-value", color = "Locus") +
  theme_bw() + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + theme(legend.position = "none")

ggplot(results, aes(x = Id, y = -log10(p.value), color = Id)) +
  geom_point() +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed") +
  labs(x = "Locus", y = "p-value", color = "Locus") +
  theme_bw() + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + theme(legend.position = "none") + scale_y_continuous(trans='log10')
```

## Let's look at Allele2 compared to Allele2UsingOfftargetRegions
Consider plotting a loci with Allele2 AND Allele2UsingOffTarget (sanity check)
Scatter (look for outliers in plot, maybe draw line of where we expect error)
Could use Allele2UOT with more confidenceâ€¦

``` {r allele2check, fig.width=15}
ggplot(gnomADSTRcalls) + geom_point(aes(x = Allele2, y = Allele2UsingOfftargetRegions, col=Id)) + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + ylim(0,400)
```

``` {r allele1check, fig.width=15}
ggplot(gnomADSTRcalls) + geom_point(aes(x = Allele1, y = Allele1UsingOfftargetRegions, col=Id)) + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + ylim(0,400)
```

``` {r allele1vs2check, fig.width=15}
ggplot(gnomADSTRcalls) + geom_point(aes(x = Allele1, y = Allele2, col=Id)) + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + ylim(0,400)
```


``` {r allele1vs2check, fig.width=15}
ggplot(gnomADSTRcalls) + geom_point(aes(x = Allele1UsingOfftargetRegions, y = Allele2UsingOfftargetRegions, col=Id)) + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + ylim(0,400)
```


``` {r allele2check by loci, fig.width=15,fig.height=100}

ggplot(gnomADSTRcalls) + geom_point(aes(x = Allele2, y = Allele2UsingOfftargetRegions, col=Motif)) + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), legend.position = "none") + facet_wrap(~Id, ncol=2, scales = "free") 


ggplot(gnomADSTRcalls) + geom_point(aes(x = AlleleLargest, y = Allele2UsingOfftargetRegions, col=Motif)) + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), legend.position = "none") + facet_wrap(~Id, ncol=2, scales = "free") 
```

``` {r allele1check by loci, fig.width=15,fig.height=100}
ggplot(gnomADSTRcalls) + geom_point(aes(x = Allele1, y = Allele1UsingOfftargetRegions, col=Motif)) + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), legend.position = "none") + facet_wrap(~Id, ncol=2, scales = "free") 
```

``` {r allele1vs2check by loci, fig.width=15,fig.height=100}

ggplot(gnomADSTRcalls) + geom_point(aes(x = Allele1, y = Allele2, col=Motif)) + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), legend.position = "none") + ylim(0,400) + facet_wrap(~Id, ncol=2, scales = "free") 
```

``` {r lines}
total_Hox1 <- subset(total, Id == 'HOXA13_1') # 3
total_Hox2 <- subset(total, Id == 'HOXA13_2') # 3
total_Hox3 <- subset(total, Id == 'HOXA13_3') # 3
total_phox <- subset(total, Id == 'PHOX2B') # 3
total_tbx1 <- subset(total, Id == 'TBX1') # 3
total_zic2 <- subset(total, Id == 'ZIC2') # 3
total_foxl2 <- subset(total, Id == 'FOXL2') # 3
total_bean1 <- subset(total, Id == 'BEAN1') # 5
total_rapgef2 <- subset(total, Id == 'RAPGEF2') # 5

tail(sort(table(total_Hox1$Allele2)), 3)
tail(sort(table(total_Hox2$Allele2)), 3)
tail(sort(table(total_Hox3$Allele2)), 3)
tail(sort(table(total_phox$Allele2)), 3)
tail(sort(table(total_tbx1$Allele2)), 3)
tail(sort(table(total_zic2$Allele2)), 3)
tail(sort(table(total_foxl2$Allele2)), 3)
tail(sort(table(total_bean1$Allele2)), 3)
tail(sort(table(total_rapgef2$Allele2)), 3)

unique(total_Hox1$End - total_Hox1$Start_0based)/3
unique(total_Hox2$End - total_Hox2$Start_0based)/3
unique(total_Hox3$End - total_Hox3$Start_0based)/3
unique(total_phox$End - total_phox$Start_0based)/3
unique(total_tbx1$End - total_tbx1$Start_0based)/3
unique(total_zic2$End - total_zic2$Start_0based)/3
unique(total_foxl2$End - total_foxl2$Start_0based)/3
unique(total_bean1$End - total_bean1$Start_0based)/5
unique(total_rapgef2$End - total_rapgef2$Start_0based)/5

# conclusion: 3bp repeats are defaulting to range of loci, 5bp are not, they're just messy


#total_dmd <- subset(total, Id == 'DMD') # 5
#table(total_dmd$Sex)
# XX    XY 
# 8167 10970 
# XYs for X-linked inheritance are filtered out!!!!!


#table(total_Hox1$Motif)
#table(total_Hox2$Motif)
#table(total_Hox3$Motif)


```

# Here we have the histograms, and there is a lot of overlap. So it is ugly.
https://stackoverflow.com/questions/6957549/overlaying-histograms-with-ggplot2-in-r
``` {r histograms, fig.width=15,fig.height=100}
ggplot(gnomADSTRcalls) + geom_histogram(aes(x = Allele1, fill = "Allele1", alpha = 0.2)) + geom_histogram(aes(x = Allele2, fill = "Allele2", alpha = 0.2)) + geom_histogram(aes(x = Allele1UsingOfftargetRegions, fill = "Allele1UsingOfftargetRegions", alpha = 0.2)) + geom_histogram(aes(x = Allele2UsingOfftargetRegions, fill = "Allele2UsingOfftargetRegions", alpha = 0.2)) + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + facet_wrap(~Id, ncol=2, scales = "free") 

ggplot(gnomADSTRcalls) + geom_density(aes(x = Allele1, color = "Allele1", alpha = 0.2)) + geom_density(aes(x = Allele2, color = "Allele2", alpha = 0.2)) + geom_density(aes(x = Allele1UsingOfftargetRegions, color = "Allele1UsingOfftargetRegions", alpha = 0.2)) + geom_density(aes(x = Allele2UsingOfftargetRegions, color = "Allele2UsingOfftargetRegions", alpha = 0.2)) + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + facet_wrap(~Id, ncol=2, scales = "free") 

```

## Let's see if variants fall into type by category
``` {r type}
ggplot(total) + geom_point(aes(x = Id, y = Allele2UsingOfftargetRegions, col=type)) + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size =8)) + facet_grid(~type, scales = "free_x") + ylim(0,4000) + scale_x_discrete(guide = guide_axis(check.overlap = TRUE))

```

``` {r type}
ggplot(total) + geom_point(aes(x = Id, y = Allele2, col=type)) + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size =8)) + facet_grid(~type, scales = "free_x") + ylim(0,400) + scale_x_discrete(guide = guide_axis(check.overlap = TRUE))

```
``` {r type}
ggplot(total) + geom_point(aes(x = Id, y = AlleleLargest, col=type)) + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size =8)) + facet_grid(~type, scales = "free_x") + ylim(0,400) + scale_x_discrete(guide = guide_axis(check.overlap = TRUE))

```

## Question 1
Allele size beyond pathogenic in literature
Penetrance lower than expected?

```{r Q1}
table(total$Allele2 >=  total$pathogenic_max, useNA = "ifany")
table(total$Allele2UsingOfftargetRegion >=  total$pathogenic_max)

# we care most about the min 
table(total$Allele2 >=  total$pathogenic_min)
table(total$Allele2UsingOfftargetRegion >=  total$pathogenic_min)

#Subs1<-subset(total, (!is.na(total$Allele2)) & (!is.na(total$pathogenic_max)))
#table(Subs1$Allele2 >=  Subs1$pathogenic_max)
# it's not NA in these columns that are making the discrepancy
#Allele2_greater_than_path_max <- Subs1$Allele2 > Subs1$pathogenic_max
#result1 <- aggregate(cbind(Allele2_greater_than_path_max), by = list(Subs1$Id), FUN = sum, na.rm=TRUE)

#Subs2<-subset(total, (!is.na(total$Allele2)) & (!is.na(total$pathogenic_max)) & (!is.na(total$Id)))
#table(Subs2$Allele2 >=  Subs2$pathogenic_max)
# it's not the three columns so like... what is it


# Create a logical vector to represent whether x > y for each row
# Allele2_greater_than_path_max <- total$AlleleLargest >= total$pathogenic_max
# table(Allele2_greater_than_path_max)
# 
# # Use aggregate() to count occurrences of x > y by z value
# result1 <- aggregate(cbind(Allele2_greater_than_path_max), by = list(total$Id), FUN = sum, na.rm=TRUE)
# 
# sum(result1$Allele2_greater_than_path_max)
# 
# df_summary <- total %>%
#   group_by(Id) %>%
#   summarize(Allele2_greater_than_path_max = sum(Allele2 >= pathogenic_max, na.rm = TRUE))
# 
# sum(df_summary$Allele2_greater_than_path_max)
# 
# sum(result1$Allele2_greater_than_path_max)
# 
# result2 <- aggregate(cbind(total$Allele2), by = list(total$Id), FUN = function(x) sum(!is.na(x)))
# 
# result <- merge(result1,result2)


#MIN
# Create a logical vector to represent whether x > y for each row
Allele2_greater_than_path_min <- total$Allele2LowerBound >= total$pathogenic_min
table(Allele2_greater_than_path_min)

# Use aggregate() to count occurrences of x > y by z value
result1 <- aggregate(cbind(Allele2_greater_than_path_min), by = list(total$Id), FUN = sum, na.rm=TRUE)

sum(result1$Allele2_greater_than_path_min)

result2 <- aggregate(cbind(total$Allele2), by = list(total$Id), FUN = function(x) sum(!is.na(x)))

result <- merge(result1,result2)


# Rename the columns of the result dataframe
colnames(result) <- c("Id", "Allele2>pathogenic_min", "Total_Allele2Loci_for_Id")

result$percent<- (result$`Allele2>pathogenic_min`/result$Total_Allele2Loci_for_Id)*100



sum(result$Allele2_greater_than_path_max, na.rm= TRUE)

print(result)
#ggplot(total) +
 # geom_histogram(aes(x = Allele2, fill = Id), alpha = 0.5) + facet_wrap(~Allele2 > pathogenic_max, scales = 'free_y') + theme(legend.position = "none")

#total_pabpn1 <- subset(total, Id == 'PABPN1') # 5
#table(total_pabpn1$Allele2)
```

Do i want to see how many alleles are within normal range? vs intermediate


### Let's see about if we parse these out by sex
Later, look at AD/AR
```{r sex}

total_sex <- subset(total, total$Inheritance == "XR" | total$Inheritance == "XD")

table(total_sex$Inheritance)

Allele2_greater_than_path_min <- total_sex$Allele2LowerBound >= total_sex$pathogenic_min
table(Allele2_greater_than_path_min)

# Use aggregate() to count occurrences of x > y by z value
result1 <- aggregate(cbind(Allele2_greater_than_path_min) ~ Id + Sex, data = total_sex, FUN = sum, na.rm = TRUE)

sum(result1$Allele2_greater_than_path_min)

result2 <- aggregate(cbind(Allele2_greater_than_path_min) ~ Id + Sex, data = total_sex, FUN = function(x) sum(!is.na(x)))

merge(result1,result2)

sex_result <- result1 %>% inner_join( result2, 
        by=c('Id', "Sex"))

# Rename the columns of the result dataframe
colnames(sex_result) <- c("Id", "Sex", "Allele2>pathogenic_min", "Total_Allele2Loci_for_Id")

sex_result$percent<- (sex_result$`Allele2>pathogenic_min`/sex_result$Total_Allele2Loci_for_Id)*100

sum(sex_result$Allele2_greater_than_path_min, na.rm= TRUE)

print(sex_result)


# https://cran.r-project.org/web/packages/interpretCI/vignettes/Confidence_interval_for_a_proportion.html
# https://rcompanion.org/handbook/H_02.html


library(DescTools)

calculate_ci <- function(df, successes_col, trials_col, conf_level, method) {
  
  # Calculate the estimated proportion and confidence intervals for each row
  est_props <- df[[successes_col]] / df[[trials_col]]
  cis <- BinomCI(df[[successes_col]], df[[trials_col]], conf.level = conf_level, method = method)
  
  # Extract the lower and upper confidence interval bounds
  lower_cis <- cis[, "lwr.ci"]
  upper_cis <- cis[, "upr.ci"]
  
  # Add the confidence intervals to the original data frame
  df$lower_ci <- lower_cis
  df$upper_ci <- upper_cis
  
  # Return the updated data frame
  return(df)
}

sex_result <- calculate_ci(sex_result, successes_col = "Allele2>pathogenic_min", trials_col = "Total_Allele2Loci_for_Id", conf_level = 0.95)

sex_result$lower_ci <- sex_result$lower_ci*100 
sex_result$upper_ci <- sex_result$upper_ci*100 


```

### Let's see about if we parse these out by PCR status
Later, look at AD/AR
```{r sex}

total_PCR <- subset(total, total$PcrProtocol == "pcr_free" | total$PcrProtocol == "pcr_plus")

table(total_PCR$PcrProtocol)

Allele2_greater_than_path_min <- total_PCR$Allele2LowerBound >= total_PCR$pathogenic_min
table(Allele2_greater_than_path_min)

# Use aggregate() to count occurrences of x > y by z value
result1 <- aggregate(cbind(Allele2_greater_than_path_min) ~ Id + PcrProtocol, data = total_PCR, FUN = sum, na.rm = TRUE)

sum(result1$Allele2_greater_than_path_min)

result2 <- aggregate(cbind(Allele2_greater_than_path_min) ~ Id + PcrProtocol, data = total_PCR, FUN = function(x) sum(!is.na(x)))

merge(result1,result2)

PCR_result <- result1 %>% inner_join( result2, 
        by=c('Id', "PcrProtocol"))

# Rename the columns of the result dataframe
colnames(PCR_result) <- c("Id", "PcrProtocol", "Allele2>pathogenic_min", "Total_Allele2Loci_for_Id")

PCR_result$percent<- (PCR_result$`Allele2>pathogenic_min`/PCR_result$Total_Allele2Loci_for_Id)*100

sum(PCR_result$Allele2_greater_than_path_max, na.rm= TRUE)

print(result)


# https://cran.r-project.org/web/packages/interpretCI/vignettes/Confidence_interval_for_a_proportion.html
# https://rcompanion.org/handbook/H_02.html




calculate_ci <- function(df, successes_col, trials_col, conf_level, method) {
  
  # Calculate the estimated proportion and confidence intervals for each row
  est_props <- df[[successes_col]] / df[[trials_col]]
  cis <- BinomCI(df[[successes_col]], df[[trials_col]], conf.level = conf_level, method = method)
  
  # Extract the lower and upper confidence interval bounds
  lower_cis <- cis[, "lwr.ci"]
  upper_cis <- cis[, "upr.ci"]
  
  # Add the confidence intervals to the original data frame
  df$lower_ci <- lower_cis
  df$upper_ci <- upper_cis
  
  # Return the updated data frame
  return(df)
}

PCR_result <- calculate_ci(PCR_result, successes_col = "Allele2>pathogenic_min", trials_col = "Total_Allele2Loci_for_Id", conf_level = 0.95)


```


## Question 2
Are there individuals in gnomad older than typical age of onset with pathogenic allele size? 
Penetrance lower than expected?
Age of onset max and age_max (but consider going to age min of range) & allele2* > pathogenic age min
Could also do pathogenic age min - # to increase wiggle
Number for each locus: how many individuals, and what sizes are the allele
Off target would be niceâ€¦ because gnomad uses conservative estimates

```{r Q2}

total_subset <- total[complete.cases(total$AgeMax), ]

# Apply the condition to each row of the data frame
condition <- (total_subset$Allele2 >= total_subset$pathogenic_min) & (total_subset$AgeMin > total_subset$age_onset_max)

# Use ifelse to print a message for each row where the condition is true
result <- ifelse(condition, 
                 paste("Allele2:", total_subset$Allele2, ", pathogenic_max:", total_subset$pathogenic_max),
                 "not")

# Print the result
cat(result, sep = "\n")

# just checking the number is right
n_not_missing_age <- table(total$Age != "age_not_available")[2]

# Create a logical vector to represent whether x > y for each row

Allele2_greater_than_path_max_with_age <- (total_subset$Allele2 > total_subset$pathogenic_max) & (total_subset$AgeMax > total_subset$age_onset_max)

table(Allele2_greater_than_path_max_with_age)

result1 <- aggregate(cbind(as.numeric(Allele2_greater_than_path_max_with_age)), by = list(total_subset$disease_id), FUN = sum)

sum(result1$V1, na.rm= TRUE)


result2 <- aggregate(cbind(total_subset$disease_id), by = list(total_subset$disease_id), FUN = length)

result <- merge(result1,result2)

#sum(result$V1)
# check to make sure stuff is working

# Rename columns and calculate proportions
colnames(result) <- c("disease_id", "Count Allele2 > pathogenic_max and agemax > age_onset_max", "Allele2 Loci by Disease Id")
result$proportion <- (result$`Count Allele2 > pathogenic_max and agemax > age_onset_max` / result$`Allele2 Loci by Disease Id`)

# Print result
print(result)

# Summarize additional statistics by disease_id
result2 <- total_subset %>%
  group_by(disease_id) %>%
  summarise(min_allele2 = min(as.numeric(Allele2)), max_allele2 = max(as.numeric(Allele2)), max_pathogenic_max = max(as.numeric(pathogenic_max)))

# Merge results
bigresult <- merge(result, result2)

# Print bigresult
print(bigresult)

```


## Detour with Confidence Regions
"First, split it into two columns so we can plot it. I can think of a few plots that might be useful. Probably to start with, does the width of the confidence interval increase with allele2 size?"

```{r sanitycheck}
table(gnomADSTRcalls$Allele2LowerBound <= gnomADSTRcalls$Allele2 & gnomADSTRcalls$Allele2 <= gnomADSTRcalls$Allele2HigherBound)

table(gnomADSTRcalls$Allele2LowerBoundOTR <= gnomADSTRcalls$Allele2UsingOfftargetRegions & gnomADSTRcalls$Allele2UsingOfftargetRegions <= gnomADSTRcalls$Allele2HigherBoundOTR)

```

```{r confinterveal, fig.width=15,fig.height=100}

ggplot(gnomADSTRcalls, aes(x = Allele2, y = (Allele2HigherBound - Allele2LowerBound), col=Id)) +
  geom_point() + theme(legend.position = "none") + facet_wrap(~Id, ncol=2, scales = "free") +
  labs(y = "Width of Allele2 Confidence Interval", x = "Allele2")
```


```{r confinterveal spread out}
ggplot(gnomADSTRcalls, aes(x = gnomADSTRcalls$Allele2, y = (gnomADSTRcalls$Allele2HigherBound - gnomADSTRcalls$Allele2LowerBound), col=Id)) +
  geom_point() + theme(legend.position = "none") + facet_grid(~disease)
  labs(y = "Width of Allele2 Confidence Interval", x = "Allele2")
```
## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
