---
title: "gnomADSTRanalysis"
author: "Laurel Hiatt"
date: "2023-04-13"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library('dplyr')
library('stringr')
library('ggplot2')
library('cowplot')
library("tidyverse")
theme_set(theme_cowplot())
options(stringsAsFactors = FALSE)
```

## This is where I will put cool explanations of things

### Summary of STR table

### Summary of gnomADSTRcalls

```{r import}
gnomADSTRcalls = read.csv('/Users/quinlan/Documents/Quinlan-PhD/UDN+STRdb/STRpapercode/gnomad_STR/gnomAD_STR_genotypes__2022_01_20.tsv.gz', sep = '\t')

STR_table <- read.csv('/Users/quinlan/Documents/Quinlan-PhD/UDN+STRdb/STRpapercode/gnomad_STR/STR_table_04072023.csv')

```


## This clean up helps the STR resource table match the gnomad data
``` {r cleanup}
#cleaning up table to match gnomad syntax
STR_table$gene[STR_table$gene == "AFF2/FMR2"] <- "AFF2"
STR_table$gene[STR_table$gene == "MARCH6"] <- "MARCHF6"
STR_table$gene[STR_table$gene == "C9orf72"] <- "C9ORF72"
STR_table$gene[STR_table$gene == "ATXN8OS/ATXN8"] <- "ATXN8OS"
STR_table$gene[STR_table$gene == "NUTM2B-AS1/NUTM2B-AS1"] <- "NUTM2B-AS1"
STR_table$gene[STR_table$gene == "ARX" & STR_table$stop_hg38 == 25013697] <- "ARX_1"
STR_table$gene[STR_table$gene == "ARX" & STR_table$stop_hg38 == 25013565] <- "ARX_2"
STR_table$gene[STR_table$gene == "HOXA13" & STR_table$stop_hg38 == 27199966] <- "HOXA13_1"
STR_table$gene[STR_table$gene == "HOXA13" & STR_table$stop_hg38 == 27199861] <- "HOXA13_2"
STR_table$gene[STR_table$gene == "HOXA13" & STR_table$stop_hg38 == 27199732] <- "HOXA13_3"

```

## This is just to check and see what doesn't match
``` {r checkdata}
unique(gnomADSTRcalls$Id) -> genelist
unique(STR_table$gene) -> tablegenelist
sort(tablegenelist) -> tablegenelist


# what are the differences between the table and the gnomad gene list
tablegenelist[!(tablegenelist %in% genelist)]

genelist[!(genelist %in% tablegenelist)]

# what are the same genesbetween the table and the gnomad gene list
tablegenelist[(tablegenelist %in% genelist)]
```

## Let's merge some data

```{r merge}
STR_table_clean <-subset(STR_table, select=c("disease_id", "gene",
                                             "repeatunit_ref", "Inheritance",
                                             "type", "normal_min", "normal_max",
                                             "intermediate_min", "intermediate_max",
                                             "pathogenic_min", "pathogenic_max",
                                             "repeat_unit_lenth", "age_onset_min",
                                             "age_onset_max", "novel", "repeatunit_path_norm"))

STR_table_clean <- STR_table_clean %>%
  rename("Id" = "gene")


gnomADSTRcalls$AgeMax = as.numeric(str_sub(gnomADSTRcalls$Age,-2,-1)) # get last two char in Age. Assumes all <100

total <- merge(STR_table_clean,gnomADSTRcalls,by="Id")
```

## Let's get a subset of the merged data (optional)
``` {r subset}
total <- sample_n(total, 10000)
```

## Let's Ensure Allele2 > Allele1

``` {r allelecheck}
table(gnomADSTRcalls$Allele2 >= gnomADSTRcalls$Allele1)

```

## Let's look at Allele2 compared to Allele2UsingOfftargetRegions
Consider plotting a loci with Allele2 AND Allele2UsingOffTarget (sanity check)
Scatter (look for outliers in plot, maybe draw line of where we expect error)
Could use Allele2UOT with more confidence…

``` {r allele2check}

ggplot(total) + geom_point(aes(x = Allele2, y = Allele2UsingOfftargetRegions, col=Id)) + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + ylim(0,400)
```

``` {r allele2check by loci, fig.width=15,fig.height=100}

ggplot(total) + geom_point(aes(x = Allele2, y = Allele2UsingOfftargetRegions, col=repeatunit_path_norm)) + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + ylim(0,400) + facet_wrap(~Id, ncol=2, scales = "free")
```

## Let's see if variants fall into type by category
``` {r type}
ggplot(total) + geom_point(aes(x = Id, y = Allele2UsingOfftargetRegions, col=type)) + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size =8)) + facet_grid(~type, scales = "free_x") + ylim(0,4000) + scale_x_discrete(guide = guide_axis(check.overlap = TRUE))



```

## Question 1
Allele size beyond pathogenic in literature
Penetrance lower than expected?

```{r Q1}
table(total$Allele2 >=  total$pathogenic_max)
table(total$Allele2UsingOfftargetRegion >=  total$pathogenic_max)

# Create a logical vector to represent whether x > y for each row
Allele2_greater_than_path_max <- as.numeric(total$Allele2) > as.numeric(total$pathogenic_max)

# Use aggregate() to count occurrences of x > y by z value
result1 <- aggregate(cbind(Allele2_greater_than_path_max), by = list(total$Id), FUN = sum)

result2 <- aggregate(cbind(total$Allele2), by = list(total$Id), FUN = length)

result <- merge(result1,result2)

# Rename the columns of the result dataframe
colnames(result) <- c("Id", "Count Allele2 > pathogenic_max", "Total L Allele2Loci for Id")

result$proportion <- (result$`Count Allele2 > pathogenic_max`/result$`Total L Allele2Loci for Id`)


print(result)
#ggplot(total) +
 # geom_histogram(aes(x = Allele2, fill = Id), alpha = 0.5) + facet_wrap(~Allele2 > pathogenic_max, scales = 'free_y') + theme(legend.position = "none")
```

## Question 2
Are there individuals in gnomad older than typical age of onset with pathogenic allele size? 
Penetrance lower than expected?
Age of onset max and age_max (but consider going to age min of range) & allele2* > pathogenic age min
Could also do pathogenic age min - # to increase wiggle
Number for each locus: how many individuals, and what sizes are the allele
Off target would be nice… because gnomad uses conservative estimates

```{r Q2}

# Apply the condition to each row of the data frame
condition <- as.numeric(total_subset$Allele2) > as.numeric(total_subset$pathogenic_max) & as.numeric(total_subset$AgeMax) > as.numeric(total_subset$age_onset_max)

# Use ifelse to print a message for each row where the condition is true
result <- ifelse(condition, 
                 paste("Allele2:", total_subset$Allele2, ", pathogenic_max:", total_subset$pathogenic_max),
                 "not")

# Print the result
cat(result, sep = "\n")

# just checking the number is right
n_not_missing_age <- table(total$Age != "age_not_available")[2]

# Create a logical vector to represent whether x > y for each row

total_subset <- total[complete.cases(total$AgeMax), ]

Allele2_greater_than_path_max_with_age <- ((as.numeric(total_subset$Allele2) > as.numeric(total_subset$pathogenic_max)) & (as.numeric(total_subset$AgeMax) > as.numeric(total_subset$age_onset_max)))

print(Allele2_greater_than_path_max_with_age)

result1 <- aggregate(cbind(as.numeric(Allele2_greater_than_path_max_with_age)), by = list(total_subset$disease_id), FUN = sum)
result2 <- aggregate(cbind(total_subset$disease_id), by = list(total_subset$disease_id), FUN = length)

result <- merge(result1,result2)

#sum(result$V1)
# check to make sure stuff is working

# Rename columns and calculate proportions
colnames(result) <- c("disease_id", "Count Allele2 > pathogenic_max and agemax > age_onset_max", "Allele2 Loci by Disease Id")
result$proportion <- (result$`Count Allele2 > pathogenic_max and agemax > age_onset_max` / result$`Allele2 Loci by Disease Id`)

# Print result
print(result)

# Summarize additional statistics by disease_id
result2 <- total_subset %>%
  group_by(disease_id) %>%
  summarise(min_allele2 = min(as.numeric(Allele2)), max_allele2 = max(as.numeric(Allele2)), max_pathogenic_max = max(as.numeric(pathogenic_max)))

# Merge results
bigresult <- merge(result, result2)

# Print bigresult
print(bigresult)

```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
