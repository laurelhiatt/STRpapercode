---
title: "gnomADSTRanalysis"
author: "Laurel Hiatt"
date: "2023-04-13"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library('dplyr')
library('stringr')
library('ggplot2')
library('cowplot')
library("tidyverse")
library("broom")
library(DescTools)
library(Biostrings)
theme_set(theme_cowplot())
options(stringsAsFactors = FALSE)
```

## This is where I will put cool explanations of things

### Summary of STR table

### Summary of gnomADSTRcalls


### To do
- if recessive, are both alleles >?

#### Look at AD, AR

https://gnomad.broadinstitute.org/news/2022-01-the-addition-of-short-tandem-repeat-calls-to-gnomad/
```{r import}
gnomADSTRcalls = read.csv('/Users/quinlan/Documents/Quinlan-PhD/UDN+STRdb/STRpapercode/gnomad_STR/gnomAD_STR_genotypes__2022_01_20.tsv.gz', sep = '\t', stringsAsFactors = FALSE)

STR_table <- read.csv('/Users/quinlan/Documents/Quinlan-PhD/UDN+STRdb/STRpapercode/gnomad_STR/STR_table_05012023.csv', stringsAsFactors = FALSE)

#str(STR_table)

#str(gnomADSTRcalls)

STR_table$pathogenic_max[STR_table$pathogenic_max == "11,000"] <- 11000
STR_table$pathogenic_max <- as.integer(STR_table$pathogenic_max)
```


## This clean up helps the STR resource table match the gnomad data
``` {r cleanup}
#cleaning up table to match gnomad syntax
STR_table$gene[STR_table$gene == "AFF2/FMR2"] <- "AFF2"
STR_table$gene[STR_table$gene == "MARCH6"] <- "MARCHF6"
STR_table$gene[STR_table$gene == "C9orf72"] <- "C9ORF72"
STR_table$gene[STR_table$gene == "ATXN8OS/ATXN8"] <- "ATXN8OS"
STR_table$gene[STR_table$gene == "NUTM2B-AS1/NUTM2B-AS1"] <- "NUTM2B-AS1"
STR_table$gene[STR_table$gene == "ZNF9 / CNBP1"] <- "CNBP"

STR_table$gene[STR_table$gene == "ARX" & STR_table$stop_hg38 == 25013697] <- "ARX_1"
STR_table$gene[STR_table$gene == "ARX" & STR_table$stop_hg38 == 25013565] <- "ARX_2"
STR_table$gene[STR_table$gene == "HOXA13" & STR_table$stop_hg38 == 27199966] <- "HOXA13_1"
STR_table$gene[STR_table$gene == "HOXA13" & STR_table$stop_hg38 == 27199861] <- "HOXA13_2"
STR_table$gene[STR_table$gene == "HOXA13" & STR_table$stop_hg38 == 27199732] <- "HOXA13_3"


STR_table$repeatunit_ref[STR_table$repeatunit_ref == "GGC/CGC"] <- "NGC"


```

## This is just to check and see what doesn't match
``` {r checkdata}
unique(gnomADSTRcalls$Id) -> genelist
unique(STR_table$gene) -> tablegenelist
sort(tablegenelist) -> tablegenelist


# what are the differences between the table and the gnomad gene list
tablegenelist[!(tablegenelist %in% genelist)]

genelist[!(genelist %in% tablegenelist)]

# what are the same genesbetween the table and the gnomad gene list
tablegenelist[(tablegenelist %in% genelist)]
length(tablegenelist[(tablegenelist %in% genelist)])
# CCG in HTT is non-pathogenic but also sometimes surveyed; there might be some association with disease as founder effect?
```

## Let's figure out the motif stuff
``` {r motif}
# MotifStuff
gnomADSTRcalls[c("Allele1Motif", "Allele2Motif")] <- as.data.frame(do.call(rbind, strsplit(gnomADSTRcalls$Motif, "/")), stringsAsFactors = FALSE)
#####Make MotifLargest

gnomADSTRcalls$MotifLargest <- ifelse(is.na(gnomADSTRcalls$Allele2) | gnomADSTRcalls$Allele1 > gnomADSTRcalls$Allele2, 
                                      gnomADSTRcalls$Allele1Motif, 
                                      gnomADSTRcalls$Allele2Motif)


# Only the AATAG is in the BEAN1 loci so... let's do that
#subset(gnomADSTRcalls, gnomADSTRcalls$Id == "BEAN1" & gnomADSTRcalls$motif_norm == "AATGG")
#subset(gnomADSTRcalls, gnomADSTRcalls$Id == "BEAN1" & gnomADSTRcalls$motif_norm == "AATAG")


normalise_str <- function(in_dna) {
  if (is.null(in_dna) || length(in_dna) == 0) {
    return('')
  }
  # Generate all circular permutations of input sequence
  all_possible <- sapply(0:(nchar(in_dna)-1), function(i) paste0(substr(in_dna, i+1, nchar(in_dna)), substr(in_dna, 1, i)))
  # Sort permutations alphabetically and return the first
  return(sort(all_possible)[1])
}

# normalise_str("TAAA")


# toy <- gnomADSTRcalls[sample(nrow(gnomADSTRcalls), 20), ]
# 
# toy$motif_norm <- sapply(toy$MotifLargest, function(x) normalise_str(as.character(x)))


gnomADSTRcalls$motif_norm <- sapply(gnomADSTRcalls$MotifLargest, function(x) normalise_str(as.character(x)))
```

## Let's merge some data
### We are also going to make some new age columns
### And then we're separating out the genotype confidence intervals

```{r merge}
STR_table_clean <-subset(STR_table, select=c("disease_id", "gene",
                                             "repeatunit_ref", "Inheritance",
                                             "type", "normal_min", "normal_max",
                                             "intermediate_min", "intermediate_max",
                                             "pathogenic_min", "pathogenic_max",
                                             "repeat_unit_lenth", "age_onset_min",
                                             "age_onset_max", "novel", "repeatunit_path_plusstrand"))

colnames(STR_table_clean)[2] = "Id"

#match what's in data
STR_table_clean$repeatunit_path_plusstrand[STR_table_clean$repeatunit_path_plusstrand == "TGGAA/TAGAA"] <- "TAGAA"


STR_table_clean$repeatunit_path_normalized <- sapply(STR_table_clean$repeatunit_path_plusstrand, function(x) normalise_str(as.character(x)))


STR_table_clean$repeatunit_ref_normalized <- sapply(STR_table_clean$repeatunit_ref, function(x) normalise_str(as.character(x)))



gnomADSTRcalls$Age[gnomADSTRcalls$Age == '<20'] <- "03-19"
gnomADSTRcalls$Age[gnomADSTRcalls$Age == '>80'] <- "81-99"

gnomADSTRcalls$AgeMax = as.numeric(str_sub(gnomADSTRcalls$Age,-2,-1)) # get last two char in Age. Assumes all <100

gnomADSTRcalls$AgeMin = as.numeric(str_sub(gnomADSTRcalls$Age,1,2)) # get last two char in Age. Assumes all <100


gnomADSTRcalls[c("Allele1LowerBound", "Allele1HigherBound", "Allele2LowerBound", "Allele2HigherBound")] <- as.data.frame(do.call(rbind, strsplit(gsub("/", "-", gnomADSTRcalls$GenotypeConfidenceInterval), "-")), stringsAsFactors = FALSE)
gnomADSTRcalls[c("Allele1LowerBound", "Allele1HigherBound", "Allele2LowerBound", "Allele2HigherBound")] <- lapply(gnomADSTRcalls[c("Allele1LowerBound", "Allele1HigherBound", "Allele2LowerBound", "Allele2HigherBound")], as.integer)

gnomADSTRcalls[c("Allele1LowerBoundOTR", "Allele1HigherBoundOTR", "Allele2LowerBoundOTR", "Allele2HigherBoundOTR")] <- as.data.frame(do.call(rbind, strsplit(gsub("/", "-", gnomADSTRcalls$GenotypeConfidenceIntervalUsingOfftargetRegions), "-")), stringsAsFactors = FALSE)
gnomADSTRcalls[c("Allele1LowerBoundOTR", "Allele1HigherBoundOTR", "Allele2LowerBoundOTR", "Allele2HigherBoundOTR")] <- lapply(gnomADSTRcalls[c("Allele1LowerBound", "Allele1HigherBoundOTR", "Allele2LowerBoundOTR", "Allele2HigherBoundOTR")], as.integer)


#table(gnomADSTRcalls$Age)

#table(gnomADSTRcalls$AgeMin)
#table(gnomADSTRcalls$AgeMax)

total <- merge(STR_table_clean,gnomADSTRcalls,by="Id")

```

``` {r comparing_norm_motifs}

### regex ? 
table(total$repeatunit_path_normalized == total$motif_norm)
table(total$repeatunit_path_normalized == total$motif_norm | total$repeatunit_ref_normalized == total$motif_norm)


subset(total, repeatunit_path_normalized != motif_norm & repeatunit_ref_normalized != motif_norm,
       select = c("motif_norm", "repeatunit_ref_normalized", "repeatunit_path_normalized", "Id"))

unique(subset(total, repeatunit_path_normalized != motif_norm & repeatunit_ref_normalized != motif_norm,
       select = c("motif_norm", "repeatunit_ref_normalized", "repeatunit_path_normalized", "Id")))

mismatchmotif <- total %>%
  subset(repeatunit_path_normalized != motif_norm & repeatunit_ref_normalized != motif_norm,
         select = c("motif_norm", "repeatunit_ref_normalized", "repeatunit_path_normalized", "Id")) %>%
  count(Id, motif_norm, repeatunit_ref_normalized, repeatunit_path_normalized)

subset(total, total$motif_norm == "ATGTT" & total$Id == "YEATS2")
```


## Let's get a subset of the merged data (optional)
``` {r subset}
#total <- sample_n(total, 10000)
```

## Let's Ensure Allele2 > Allele1
- Check max of allele1 and allele2 (na.rm = TRUE)


``` {r allelecheck}
#table(gnomADSTRcalls$Allele2 >= gnomADSTRcalls$Allele1, useNA = "ifany")
#pmax(gnomADSTRcalls$Allele1, gnomADSTRcalls$Allele2, na.rm = TRUE)

# gnomADSTRcalls_noallele2 <- gnomADSTRcalls[is.na(gnomADSTRcalls$Allele2),]
# table(gnomADSTRcalls_noallele2$Allele1)

gnomADSTRcalls$AlleleLargest <- pmax(gnomADSTRcalls$Allele1, gnomADSTRcalls$Allele2, na.rm = TRUE)
#table(gnomADSTRcalls$AlleleLargest)
#table(gnomADSTRcalls$AlleleLargest >= gnomADSTRcalls$Allele1, useNA = "ifany")

```

## Loop from harriet for allele distribution with age vs no age available
```{r loop}
for (locus in unique(gnomADSTRcalls$Id)) {
  ggplot(subset(gnomADSTRcalls, Id == locus)) + 
    geom_histogram(aes(x = Allele2, fill = Age), alpha = 0.5) + 
    facet_wrap(~AgeMax == 'age_not_available', scales = 'free_y') +
    ggtitle(locus)
  ggsave(paste0(locus,'_allele2_age_available.png'))
}

for (locus in unique(gnomADSTRcalls$Id)) {
  ggplot(subset(gnomADSTRcalls, Id == locus)) + 
    geom_histogram(aes(x = Allele2UsingOfftargetRegions, fill = Age), alpha = 0.5) + 
    facet_wrap(~AgeMax == '_OTR_age_not_available', scales = 'free_y') +
    ggtitle(locus)
  ggsave(paste0(locus,'_OTR_allele2_age_available.png'))
}

table(gnomADSTRcalls$Age)

wilcox.test(subset(gnomADSTRcalls, Age == 'age_not_available')$Allele2, 
                          subset(gnomADSTRcalls, Age != 'age_not_available')$Allele2)


# results <- data.frame()  # create an empty dataframe to store results
# 
# for (locus in unique(gnomADSTRcalls$Id)) {
#   p <- tidy(ks.test(subset(gnomADSTRcalls, Age == 'age_not_available' & Id == locus)$Allele2, 
#                          subset(gnomADSTRcalls, Age != 'age_not_available'& Id == locus)$Allele2))
#   results <- rbind(results, data.frame(Id = locus, statistic = p$statistic, p.value = p$p.value))
# }
# 
# print(results)

# NOT ENOUGH Y DATA!!!
```

## PCR comparison
``` {r PCR, fig.width=15,fig.height=10}

ggplot(gnomADSTRcalls) + 
  geom_histogram(aes(x = Allele2, fill = PcrProtocol), alpha = 0.5) + 
  facet_wrap(~PcrProtocol, scales = 'free_y') +
  ggtitle('PCR Protocol')

# 
# wilcox.test(subset(gnomADSTRcalls, PcrProtocol == 'pcr_free')$Allele2, 
#              subset(gnomADSTRcalls, PcrProtocol == 'pcr_plus')$Allele2)
# p <- tidy(wilcox.test(subset(gnomADSTRcalls, PcrProtocol == 'pcr_free')$Allele2, 
#              subset(gnomADSTRcalls, PcrProtocol == 'pcr_plus')$Allele2))


# for (locus in unique(gnomADSTRcalls$Id)) {
#   cat(paste0(locus))
#   p <- tidy(wilcox.test(subset(gnomADSTRcalls, PcrProtocol == 'pcr_free' & Id == locus)$Allele2, 
#              subset(gnomADSTRcalls, PcrProtocol == 'pcr_plus'& Id == locus)$Allele2))
#   cat('\n') 
#   cat("The statistic is \n")
#   cat(p$statistic)
#   cat('\n') 
#   cat("The p-value is \n")
#   cat(p$p.value)
#   cat('\n') 
# }

results <- data.frame()  # create an empty dataframe to store results

for (locus in unique(gnomADSTRcalls$Id)) {
  p <- tidy(wilcox.test(subset(gnomADSTRcalls, PcrProtocol == 'pcr_free' & Id == locus)$Allele2, 
                         subset(gnomADSTRcalls, PcrProtocol == 'pcr_plus'& Id == locus)$Allele2))
  results <- rbind(results, data.frame(Id = locus, statistic = p$statistic, p.value = p$p.value))
}

print(results)

ggplot(results, aes(x = Id, y = p.value, color = Id)) +
  geom_point() +
  geom_hline(yintercept = 0.05, linetype = "dashed") +
  labs(x = "Locus", y = "p-value", color = "Locus") +
  theme_bw() + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + theme(legend.position = "none")

ggplot(results, aes(x = Id, y = -log10(p.value), color = Id)) +
  geom_point() +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed") +
  labs(x = "Locus", y = "p-value", color = "Locus") +
  theme_bw() + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + theme(legend.position = "none") + scale_y_continuous(trans='log10')
```

## Let's look at Allele2 compared to Allele2UsingOfftargetRegions
Consider plotting a loci with Allele2 AND Allele2UsingOffTarget (sanity check)
Scatter (look for outliers in plot, maybe draw line of where we expect error)
Could use Allele2UOT with more confidence…

``` {r allele2check, fig.width=15}
ggplot(gnomADSTRcalls) + geom_point(aes(x = Allele2, y = Allele2UsingOfftargetRegions, col=Id)) + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + ylim(0,400)
```

``` {r allele1check, fig.width=15}
ggplot(gnomADSTRcalls) + geom_point(aes(x = Allele1, y = Allele1UsingOfftargetRegions, col=Id)) + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + ylim(0,400)
```

``` {r allele1vs2check, fig.width=15}
ggplot(gnomADSTRcalls) + geom_point(aes(x = Allele1, y = Allele2, col=Id)) + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + ylim(0,400)
```


``` {r allele1vs2check, fig.width=15}
ggplot(gnomADSTRcalls) + geom_point(aes(x = Allele1UsingOfftargetRegions, y = Allele2UsingOfftargetRegions, col=Id)) + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + ylim(0,400)
```


``` {r allele2check by loci, fig.width=15,fig.height=300}

ggplot(gnomADSTRcalls) + geom_point(aes(x = Allele2, y = Allele2UsingOfftargetRegions, col=Motif)) + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), legend.position = "none") + facet_wrap(~Id, ncol=2, scales = "free") 


ggplot(gnomADSTRcalls) + geom_point(aes(x = AlleleLargest, y = Allele2UsingOfftargetRegions, col=Motif)) + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), legend.position = "none") + facet_wrap(Id~motif_norm, ncol=2, scales = "free") + geom_abline(slope=1,intercept=0, col="gray")
```

``` {r allele1check by loci, fig.width=15,fig.height=100}
ggplot(gnomADSTRcalls) + geom_point(aes(x = Allele1, y = Allele1UsingOfftargetRegions, col=Motif)) + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), legend.position = "none") + facet_wrap(~Id, ncol=2, scales = "free") 
```

``` {r allele1vs2check by loci, fig.width=15,fig.height=100}

ggplot(gnomADSTRcalls) + geom_point(aes(x = Allele1, y = Allele2, col=Motif)) + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), legend.position = "none") + ylim(0,400) + facet_wrap(~Id, ncol=2, scales = "free") 
```

``` {r lines}
total_Hox1 <- subset(total, Id == 'HOXA13_1') # 3
total_Hox2 <- subset(total, Id == 'HOXA13_2') # 3
total_Hox3 <- subset(total, Id == 'HOXA13_3') # 3
total_phox <- subset(total, Id == 'PHOX2B') # 3
total_tbx1 <- subset(total, Id == 'TBX1') # 3
total_zic2 <- subset(total, Id == 'ZIC2') # 3
total_foxl2 <- subset(total, Id == 'FOXL2') # 3
total_bean1 <- subset(total, Id == 'BEAN1') # 5
total_rapgef2 <- subset(total, Id == 'RAPGEF2') # 5

tail(sort(table(total_Hox1$Allele2)), 3)
tail(sort(table(total_Hox2$Allele2)), 3)
tail(sort(table(total_Hox3$Allele2)), 3)
tail(sort(table(total_phox$Allele2)), 3)
tail(sort(table(total_tbx1$Allele2)), 3)
tail(sort(table(total_zic2$Allele2)), 3)
tail(sort(table(total_foxl2$Allele2)), 3)
tail(sort(table(total_bean1$Allele2)), 3)
tail(sort(table(total_rapgef2$Allele2)), 3)

unique(total_Hox1$End - total_Hox1$Start_0based)/3
unique(total_Hox2$End - total_Hox2$Start_0based)/3
unique(total_Hox3$End - total_Hox3$Start_0based)/3
unique(total_phox$End - total_phox$Start_0based)/3
unique(total_tbx1$End - total_tbx1$Start_0based)/3
unique(total_zic2$End - total_zic2$Start_0based)/3
unique(total_foxl2$End - total_foxl2$Start_0based)/3
unique(total_bean1$End - total_bean1$Start_0based)/5
unique(total_rapgef2$End - total_rapgef2$Start_0based)/5

# conclusion: 3bp repeats are defaulting to range of loci, 5bp are not, they're just messy


#total_dmd <- subset(total, Id == 'DMD') # 5
#table(total_dmd$Sex)
# XX    XY 
# 8167 10970 
# XYs for X-linked inheritance are filtered out!!!!!


#table(total_Hox1$Motif)
#table(total_Hox2$Motif)
#table(total_Hox3$Motif)


```

# Here we have the histograms, and there is a lot of overlap. So it is ugly.
https://stackoverflow.com/questions/6957549/overlaying-histograms-with-ggplot2-in-r
``` {r histograms, fig.width=15,fig.height=100}
ggplot(gnomADSTRcalls) + geom_histogram(aes(x = Allele1, fill = "Allele1", alpha = 0.2)) + geom_histogram(aes(x = Allele2, fill = "Allele2", alpha = 0.2)) + geom_histogram(aes(x = Allele1UsingOfftargetRegions, fill = "Allele1UsingOfftargetRegions", alpha = 0.2)) + geom_histogram(aes(x = Allele2UsingOfftargetRegions, fill = "Allele2UsingOfftargetRegions", alpha = 0.2)) + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + facet_wrap(~Id, ncol=2, scales = "free") 

ggplot(gnomADSTRcalls) + geom_density(aes(x = Allele1, color = "Allele1", alpha = 0.2)) + geom_density(aes(x = Allele2, color = "Allele2", alpha = 0.2)) + geom_density(aes(x = Allele1UsingOfftargetRegions, color = "Allele1UsingOfftargetRegions", alpha = 0.2)) + geom_density(aes(x = Allele2UsingOfftargetRegions, color = "Allele2UsingOfftargetRegions", alpha = 0.2)) + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + facet_wrap(~Id, ncol=2, scales = "free") 

```

## Let's see if variants fall into type by category
``` {r type}
ggplot(total) + geom_point(aes(x = Id, y = Allele2UsingOfftargetRegions, col=type)) + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size =8)) + facet_grid(~type, scales = "free_x") + ylim(0,4000) + scale_x_discrete(guide = guide_axis(check.overlap = TRUE))

```

``` {r type}
ggplot(total) + geom_point(aes(x = Id, y = Allele2, col=type)) + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size =8)) + facet_grid(~type, scales = "free_x") + ylim(0,400) + scale_x_discrete(guide = guide_axis(check.overlap = TRUE))

```



``` {r type}
ggplot(total) + geom_point(aes(x = Id, y = AlleleLargest, col=type)) + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size =8)) + facet_grid(~type, scales = "free_x") + ylim(0,400) + scale_x_discrete(guide = guide_axis(check.overlap = TRUE))

```

## Question 1
Allele size beyond pathogenic in literature
Penetrance lower than expected?

```{r Q1}
table(total$Allele2 >=  total$pathogenic_max, useNA = "ifany")
table(total$Allele2UsingOfftargetRegion >=  total$pathogenic_max)

# we care most about the min 
table(total$Allele2 >=  total$pathogenic_min)
table(total$Allele2UsingOfftargetRegion >=  total$pathogenic_min)

#Subs1<-subset(total, (!is.na(total$Allele2)) & (!is.na(total$pathogenic_max)))
#table(Subs1$Allele2 >=  Subs1$pathogenic_max)
# it's not NA in these columns that are making the discrepancy
#Allele2_greater_than_path_max <- Subs1$Allele2 > Subs1$pathogenic_max
#result1 <- aggregate(cbind(Allele2_greater_than_path_max), by = list(Subs1$Id), FUN = sum, na.rm=TRUE)

#Subs2<-subset(total, (!is.na(total$Allele2)) & (!is.na(total$pathogenic_max)) & (!is.na(total$Id)))
#table(Subs2$Allele2 >=  Subs2$pathogenic_max)
# it's not the three columns so like... what is it


# Create a logical vector to represent whether x > y for each row
# Allele2_greater_than_path_max <- total$AlleleLargest >= total$pathogenic_max
# table(Allele2_greater_than_path_max)
# 
# # Use aggregate() to count occurrences of x > y by z value
# result1 <- aggregate(cbind(Allele2_greater_than_path_max), by = list(total$Id), FUN = sum, na.rm=TRUE)
# 
# sum(result1$Allele2_greater_than_path_max)
# 
# df_summary <- total %>%
#   group_by(Id) %>%
#   summarize(Allele2_greater_than_path_max = sum(Allele2 >= pathogenic_max, na.rm = TRUE))
# 
# sum(df_summary$Allele2_greater_than_path_max)
# 
# sum(result1$Allele2_greater_than_path_max)
# 
# result2 <- aggregate(cbind(total$Allele2), by = list(total$Id), FUN = function(x) sum(!is.na(x)))
# 
# result <- merge(result1,result2)


#MIN
# Create a logical vector to represent whether x > y for each row
Allele2_greater_than_path_min <- total$Allele2LowerBound >= total$pathogenic_min
table(Allele2_greater_than_path_min)

# Use aggregate() to count occurrences of x > y by z value
result1 <- aggregate(cbind(Allele2_greater_than_path_min), by = list(total$Id), FUN = sum, na.rm=TRUE)

sum(result1$Allele2_greater_than_path_min)

result2 <- aggregate(cbind(total$Allele2), by = list(total$Id), FUN = function(x) sum(!is.na(x)))

result <- merge(result1,result2)


# Rename the columns of the result dataframe
colnames(result) <- c("Id", "Allele2>pathogenic_min", "Total_Allele2Loci_for_Id")

result$percent<- (result$`Allele2>pathogenic_min`/result$Total_Allele2Loci_for_Id)*100



calculate_ci <- function(df, successes_col, trials_col, conf_level, method) {
  
  # Calculate the estimated proportion and confidence intervals for each row
  est_props <- df[[successes_col]] / df[[trials_col]]
  cis <- BinomCI(df[[successes_col]], df[[trials_col]], conf.level = conf_level, method = method)
  
  # Extract the lower and upper confidence interval bounds
  lower_cis <- cis[, "lwr.ci"]
  upper_cis <- cis[, "upr.ci"]
  
  # Add the confidence intervals to the original data frame
  df$lower_ci <- lower_cis*100
  df$upper_ci <- upper_cis*100
  
  # Return the updated data frame
  return(df)
}

result <- calculate_ci(result, successes_col = "Allele2>pathogenic_min", trials_col = "Total_Allele2Loci_for_Id", conf_level = 0.95)

ggplot(result, aes(x = reorder(Id,percent), y = percent, color = Id)) +
  geom_point() +
  geom_errorbar(aes(ymin = lower_ci, ymax = upper_ci), width = 0.2) +
  xlab("Id") +  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size =8), legend.position = "none") +
  ylab("Pathogenic Percentage") +
  ggtitle("Pathogenic Percentage by Id with 95% CI")

#ggplot(total) +
 # geom_histogram(aes(x = Allele2, fill = Id), alpha = 0.5) + facet_wrap(~Allele2 > pathogenic_max, scales = 'free_y') + theme(legend.position = "none")

#total_pabpn1 <- subset(total, Id == 'PABPN1') # 5
#table(total_pabpn1$Allele2)
```

Do i want to see how many alleles are within normal range? vs intermediate


### Let's see about if we parse these out by sex
Later, look at AD/AR
```{r sex}

total_sex <- subset(total, total$Inheritance == "XR" | total$Inheritance == "XD")

table(total_sex$Inheritance)

Allele2_greater_than_path_min <- total_sex$Allele2LowerBound >= total_sex$pathogenic_min
table(Allele2_greater_than_path_min)

# Use aggregate() to count occurrences of x > y by z value
result1 <- aggregate(cbind(Allele2_greater_than_path_min) ~ Id + Sex, data = total_sex, FUN = sum, na.rm = TRUE)

sum(result1$Allele2_greater_than_path_min)

result2 <- aggregate(cbind(Allele2_greater_than_path_min) ~ Id + Sex, data = total_sex, FUN = function(x) sum(!is.na(x)))

merge(result1,result2)

sex_result <- result1 %>% inner_join( result2, 
        by=c('Id', "Sex"))

# Rename the columns of the result dataframe
colnames(sex_result) <- c("Id", "Sex", "Allele2>pathogenic_min", "Total_Allele2Loci_for_Id")

sex_result$percent<- (sex_result$`Allele2>pathogenic_min`/sex_result$Total_Allele2Loci_for_Id)*100

sum(sex_result$Allele2_greater_than_path_min, na.rm= TRUE)

print(sex_result)


# https://cran.r-project.org/web/packages/interpretCI/vignettes/Confidence_interval_for_a_proportion.html
# https://rcompanion.org/handbook/H_02.html

calculate_ci <- function(df, successes_col, trials_col, conf_level, method) {
  
  # Calculate the estimated proportion and confidence intervals for each row
  est_props <- df[[successes_col]] / df[[trials_col]]
  cis <- BinomCI(df[[successes_col]], df[[trials_col]], conf.level = conf_level, method = method)
  
  # Extract the lower and upper confidence interval bounds
  lower_cis <- cis[, "lwr.ci"]
  upper_cis <- cis[, "upr.ci"]
  
  # Add the confidence intervals to the original data frame
  df$lower_ci <- lower_cis*100
  df$upper_ci <- upper_cis*100
  
  # Return the updated data frame
  return(df)
}

sex_result <- calculate_ci(sex_result, successes_col = "Allele2>pathogenic_min", trials_col = "Total_Allele2Loci_for_Id", conf_level = 0.95)

ggplot(sex_result, aes(x = reorder(Id,percent), y = percent, color = Sex)) +
  geom_point() +
  geom_errorbar(aes(ymin = lower_ci, ymax = upper_ci), width = 0.2) +
  xlab("Id") +  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size =8)) +
  ylab("Pathogenic Percentage") +
  ggtitle("Pathogenic Percentage by Id with 95% CI with Sex Info")


```


### Inheritance patterns?
```{r inheritance}

Allele2_greater_than_path_min <- total$Allele2LowerBound >= total$pathogenic_min
table(Allele2_greater_than_path_min)

# Use aggregate() to count occurrences of x > y by z value
result1 <- aggregate(cbind(Allele2_greater_than_path_min) ~ Id + Inheritance, data = total, FUN = sum, na.rm = TRUE)

sum(result1$Allele2_greater_than_path_min)

result2 <- aggregate(cbind(Allele2_greater_than_path_min) ~ Id + Inheritance, data = total, FUN = function(x) sum(!is.na(x)))

merge(result1,result2)

inheritance_result <- result1 %>% inner_join( result2, 
        by=c('Id', "Inheritance"))

# Rename the columns of the result dataframe
colnames(inheritance_result) <- c("Id", "Inheritance", "Allele2>pathogenic_min", "Total_Allele2Loci_for_Id")

inheritance_result$percent<- (inheritance_result$`Allele2>pathogenic_min`/inheritance_result$Total_Allele2Loci_for_Id)*100

sum(inheritance_result$Allele2_greater_than_path_min, na.rm= TRUE)

print(sex_result)

# https://cran.r-project.org/web/packages/interpretCI/vignettes/Confidence_interval_for_a_proportion.html
# https://rcompanion.org/handbook/H_02.html

# calculate_ci <- function(df, successes_col, trials_col, conf_level, method) {
#   
#   # Calculate the estimated proportion and confidence intervals for each row
#   est_props <- df[[successes_col]] / df[[trials_col]]
#   cis <- BinomCI(df[[successes_col]], df[[trials_col]], conf.level = conf_level, method = method)
#   
#   # Extract the lower and upper confidence interval bounds
#   lower_cis <- cis[, "lwr.ci"]
#   upper_cis <- cis[, "upr.ci"]
#   
#   # Add the confidence intervals to the original data frame
#   df$lower_ci <- lower_cis*100
#   df$upper_ci <- upper_cis*100
#   
#   # Return the updated data frame
#   return(df)
# }

inheritance_result <- calculate_ci(inheritance_result, successes_col = "Allele2>pathogenic_min", trials_col = "Total_Allele2Loci_for_Id", conf_level = 0.95)

ggplot(inheritance_result, aes(x = reorder(Id,percent), y = percent, color = Inheritance)) +
  geom_point() +
  geom_errorbar(aes(ymin = lower_ci, ymax = upper_ci), width = 0.2) +
  xlab("Id") +  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size =8)) +
  ylab("Pathogenic Percentage") +
  ggtitle("Pathogenic Percentage by Id with 95% CI with Inheritance Info")


```
### Let's see about if we parse these out by PCR status
```{r PCRT}

total_PCR <- subset(total, total$PcrProtocol == "pcr_free" | total$PcrProtocol == "pcr_plus")

table(total_PCR$PcrProtocol)

Allele2_greater_than_path_min <- total_PCR$Allele2LowerBound >= total_PCR$pathogenic_min
table(Allele2_greater_than_path_min)

# Use aggregate() to count occurrences of x > y by z value
result1 <- aggregate(cbind(Allele2_greater_than_path_min) ~ Id + PcrProtocol, data = total_PCR, FUN = sum, na.rm = TRUE)

result2 <- aggregate(cbind(Allele2_greater_than_path_min) ~ Id + PcrProtocol, data = total_PCR, FUN = function(x) sum(!is.na(x)))

merge(result1,result2)

PCR_result <- result1 %>% inner_join( result2, 
        by=c('Id', "PcrProtocol"))

# Rename the columns of the result dataframe
colnames(PCR_result) <- c("Id", "PcrProtocol", "Allele2>pathogenic_min", "Total_Allele2Loci_for_Id")

PCR_result$percent<- (PCR_result$`Allele2>pathogenic_min`/PCR_result$Total_Allele2Loci_for_Id)*100

sum(PCR_result$Allele2_greater_than_path_max, na.rm= TRUE)

print(result)


# https://cran.r-project.org/web/packages/interpretCI/vignettes/Confidence_interval_for_a_proportion.html
# https://rcompanion.org/handbook/H_02.html

# 
# calculate_ci <- function(df, successes_col, trials_col, conf_level, method) {
#   
#   # Calculate the estimated proportion and confidence intervals for each row
#   est_props <- df[[successes_col]] / df[[trials_col]]
#   cis <- BinomCI(df[[successes_col]], df[[trials_col]], conf.level = conf_level, method = method)
#   
#   # Extract the lower and upper confidence interval bounds
#   lower_cis <- cis[, "lwr.ci"]
#   upper_cis <- cis[, "upr.ci"]
#   
#   # Add the confidence intervals to the original data frame
#   df$lower_ci <- lower_cis*100
#   df$upper_ci <- upper_cis*100
#   
#   # Return the updated data frame
#   return(df)
# }

PCR_result <- calculate_ci(PCR_result, successes_col = "Allele2>pathogenic_min", trials_col = "Total_Allele2Loci_for_Id", conf_level = 0.95)

#### PLOT WITH PERCENTAGE DATA!!!!!

```


## Question 2
Are there individuals in gnomad older than typical age of onset with pathogenic allele size? 
Penetrance lower than expected?
Age of onset max and age_max (but consider going to age min of range) & allele2* > pathogenic age min
Could also do pathogenic age min - # to increase wiggle
Number for each locus: how many individuals, and what sizes are the allele
Off target would be nice… because gnomad uses conservative estimates

```{r Q2 disease id}

total_subset <- total[complete.cases(total$AgeMin), ]

total_subset$AgeMin <- as.integer(total_subset$AgeMin)

# # Apply the condition to each row of the data frame
# condition <- (total_subset$AlleleLargest >= total_subset$pathogenic_min) & (total_subset$AgeMin > total_subset$age_onset_max)
# 
# # Use ifelse to print a message for each row where the condition is true
# result <- ifelse(condition, 
#                  paste("Allele2:", total_subset$Allele2, ", pathogenic_max:", total_subset$pathogenic_max),
#                  "not")
# 
# # Print the result
# cat(result, sep = "\n")
# 
# # just checking the number is right
# n_not_missing_age <- table(total$Age != "age_not_available")[2]

# Create a logical vector to represent whether x > y for each row

Allele2_greater_than_path_max_with_age <- (total_subset$AlleleLargest >= total_subset$pathogenic_max) & (total_subset$AgeMin >= total_subset$age_onset_max)

table(Allele2_greater_than_path_max_with_age)

result1 <- aggregate(cbind(as.numeric(Allele2_greater_than_path_max_with_age)), by = list(total_subset$disease_id), FUN = sum)

sum(result1$V1, na.rm= TRUE)

result2 <- aggregate(cbind(total_subset$disease_id), by = list(total_subset$disease_id), FUN = function(x) sum(!is.na(x)))

colnames(result1) <- c("disease_id", "Allele2>pathogenic_max&agemax>age_onset_max")
colnames(result2) <- c("disease_id", "Allele2_Loci_by_Disease_Id")


result <- merge(result1,result2)

result$percent <- result$`Allele2>pathogenic_max&agemax>age_onset_max`/result$Allele2_Loci_by_Disease_Id*100

# Print result
print(result)

# Summarize additional statistics by disease_id
result2 <- total_subset %>%
  group_by(disease_id) %>%
  summarise(min_allele2 = min(as.numeric(Allele2)), max_allele2 = max(as.numeric(Allele2)), max_pathogenic_max = max(as.numeric(pathogenic_max)))

# Merge results
bigresult <- merge(result, result2)

# Print bigresult
print(bigresult)

```

```{r Q2 id}

total_subset <- total[complete.cases(total$AgeMin), ]

total_subset$AgeMin <- as.integer(total_subset$AgeMin)

# # Apply the condition to each row of the data frame
# condition <- (total_subset$AlleleLargest >= total_subset$pathogenic_min) & (total_subset$AgeMin > total_subset$age_onset_max)
# 
# # Use ifelse to print a message for each row where the condition is true
# result <- ifelse(condition, 
#                  paste("Allele2:", total_subset$Allele2, ", pathogenic_max:", total_subset$pathogenic_max),
#                  "not")
# 
# # Print the result
# cat(result, sep = "\n")
# 
# # just checking the number is right
# n_not_missing_age <- table(total$Age != "age_not_available")[2]

# Create a logical vector to represent whether x > y for each row

Allele2_greater_than_path_max_with_age <- (total_subset$Allele2LowerBound >= total_subset$pathogenic_max) & (total_subset$AgeMin >= total_subset$age_onset_max)

table(Allele2_greater_than_path_max_with_age)

result1 <- aggregate(cbind(as.numeric(Allele2_greater_than_path_max_with_age)), by = list(total_subset$Id), FUN = sum)

sum(result1$V1, na.rm= TRUE)

result2 <- aggregate(cbind(total_subset$disease_id), by = list(total_subset$Id), FUN = function(x) sum(!is.na(x)))

colnames(result1) <- c("Id", "Allele2>pathogenic_max&agemax>age_onset_max")
colnames(result2) <- c("Id", "Allele2_Loci_by_Id")


result <- merge(result1,result2)

result$percent <- result$`Allele2>pathogenic_max&agemax>age_onset_max`/result$Allele2_Loci_by_Id*100

result <- calculate_ci(result, successes_col = "Allele2>pathogenic_max&agemax>age_onset_max", trials_col = "Allele2_Loci_by_Id", conf_level = 0.95)

ggplot(result, aes(x = reorder(Id,percent), y = percent, color = Id)) +
  geom_point() +
  geom_errorbar(aes(ymin = lower_ci, ymax = upper_ci), width = 0.2) +
  xlab("Id") +  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size =8), legend.position = "none") +
  ylab("Pathogenic Percentage") + 
  ggtitle("Pathogenic Percentage Over Age by Id with 95% CI ")

# 
# 
# # Summarize additional statistics by disease_id
# result2 <- total_subset %>%
#   group_by(disease_id) %>%
#   summarise(min_allele2 = min(as.numeric(Allele2)), max_allele2 = max(as.numeric(Allele2)), max_pathogenic_max = max(as.numeric(pathogenic_max)))
# 
# # Merge results
# bigresult <- merge(result, result2)
# 
# # Print bigresult
# print(bigresult)

```
## Detour with Confidence Regions
"First, split it into two columns so we can plot it. I can think of a few plots that might be useful. Probably to start with, does the width of the confidence interval increase with allele2 size?"

```{r sanitycheck}
table(gnomADSTRcalls$Allele2LowerBound <= gnomADSTRcalls$Allele2 & gnomADSTRcalls$Allele2 <= gnomADSTRcalls$Allele2HigherBound)

table(gnomADSTRcalls$Allele2LowerBoundOTR <= gnomADSTRcalls$Allele2UsingOfftargetRegions & gnomADSTRcalls$Allele2UsingOfftargetRegions <= gnomADSTRcalls$Allele2HigherBoundOTR)

```

```{r confinterveal, fig.width=15,fig.height=100}

ggplot(gnomADSTRcalls, aes(x = Allele2, y = (Allele2HigherBound - Allele2LowerBound), col=Id)) +
  geom_point() + theme(legend.position = "none") + facet_wrap(~Id, ncol=2, scales = "free") +
  labs(y = "Width of Allele2 Confidence Interval", x = "Allele2")
```


```{r confinterveal spread out}
ggplot(gnomADSTRcalls, aes(x = gnomADSTRcalls$Allele2, y = (gnomADSTRcalls$Allele2HigherBound - gnomADSTRcalls$Allele2LowerBound), col=Id)) +
  geom_point() + theme(legend.position = "none") + facet_grid(~Id) + 
  labs(y = "Width of Allele2 Confidence Interval", x = "Allele2")
```




## Including Plots
# Do this after motifs have been separated. Then use one of the motifs sizes as the nchar bit. May need to finess RFC1 because it can have different motif sizes

gnomADSTRcalls$RefAllele = round((gnomADSTRcalls$End - gnomADSTRcalls$Start_0based)/nchar(gnomADSTRcalls$Motif))

ggplot(gnomADSTRcalls, 
       aes(x = Allele1,
           fill = Allele1 == RefAllele)
) + 
  geom_bar() + facet_wrap(~Id, ncol=3, scales = "free")
ggsave('Allele1_isref.pdf', height = 50, width = 20, limitsize = FALSE)

ggplot(subset(gnomADSTRcalls, !is.na(Allele2)), 
       aes(x = Allele2,
           fill = Allele2 == RefAllele)
) + 
  geom_bar() + facet_wrap(~Id, ncol=3, scales = "free")
ggsave('Allele2_isref.pdf', height = 50, width = 20, limitsize = FALSE)

ggplot(gnomADSTRcalls, 
       aes(x = Allele1UsingOfftargetRegions,
           fill = Allele1UsingOfftargetRegions == RefAllele)
       ) + 
  geom_bar() + facet_wrap(~Id, ncol=3, scales = "free")
ggsave('Allele1OTR_isref.pdf', height = 50, width = 20, limitsize = FALSE)

ggplot(subset(gnomADSTRcalls, !is.na(Allele2UsingOfftargetRegions)), 
       aes(x = Allele2UsingOfftargetRegions,
           fill = Allele2UsingOfftargetRegions == RefAllele)
) + 
  geom_bar() + facet_wrap(~Id, ncol=3, scales = "free")
ggsave('Allele2OTR_isref.pdf', height = 50, width = 20, limitsize = FALSE)

# Fill by motif first, then separate by motif if needed. (edited) 

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
